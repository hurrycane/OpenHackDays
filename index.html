<!DOCTYPE HTML> 
<html lang="en"> 
	<head> 
		<title>three.js webgl - interactive - voxel painter</title>
		<script type="text/javascript" src="javascripts/Three.js"></script> 
 
		<script type="text/javascript" src="javascripts/Detector.js"></script> 
		<script type="text/javascript" src="javascripts/RequestAnimationFrame.js"></script> 
		<script type="text/javascript" src="javascripts/Stats.js"></script> 
		
		<style type="text/css"> 
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

			#oldie { background-color: #ddd !important }
		</style>
	</head> 
	<body>
		<script type="text/javascript"> 
		  if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
		  
		  container = document.createElement('div');
		  document.body.appendChild(container);
		  
		  var voxelPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3();
      camera = new THREE.QuakeCamera( {
       fov: 60, aspect: window.innerWidth / window.innerHeight, near: 1, far: 20000,
       movementSpeed: 250, lookSpeed: 0.05, noFly: false, lookVertical: true
      } );
		  //camera = new THREE.Camera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
		  
		  
      camera.position.y = 433;
      camera.position.z = 300;
      camera.position.x = -387;
		  
		  scene = new THREE.Scene();
		  var mouse2D = new THREE.Vector3( 0, 10000, 0.5 );
		  var ray = new THREE.Ray( camera.position, null );
		  
      // // containing dome
      mesh = new THREE.Mesh( new THREE.Sphere( 10000, 60, 40 ), new THREE.MeshBasicMaterial( { color: 0xAAAAAA } ) );
      mesh.scale.x = -1;
      scene.addObject( mesh );
		  
      // maine plane
      
      rollOverGeo = new THREE.Cube( 50, 50, 50 );
			rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
			rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
			scene.addObject( rollOverMesh );
      
      var cubeMaterial = new THREE.MeshLambertMaterial( { map: THREE.ImageUtils.loadTexture( "texture.png" ) } );
      plane_oxz = new THREE.Mesh(  new THREE.Plane( 500, 500, 20, 20 ), cubeMaterial);
      plane_oxz.rotation.x = - ( Math.PI / 2 );
      plane_oxz.overdraw = true;
      scene.addObject( plane_oxz );
      
      var projector = new THREE.Projector();
      
      // maine plane down
            var cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xFFFFFF, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( "transparent.png" ) } );
            cubeMaterial.transparent = true;
            plane_oxz_two = new THREE.Mesh( new THREE.Plane( 500, 500, 25, 25 ), cubeMaterial );
            plane_oxz_two.rotation.x = ( Math.PI / 2 );
            plane_oxz_two.overdraw = true;
            scene.addObject( plane_oxz_two );
                  
            // Y plane front
            var cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xFFFFFF, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( "transparent.png" ) } );
            cubeMaterial.transparent = true;
            plane_oxy = new THREE.Mesh( new THREE.Plane(500, 500, 25, 25 ), cubeMaterial );
            plane_oxy.position.x = 0;
            plane_oxy.position.y = 250;
            plane_oxy.position.z = -250;
            plane_oxy.overdraw = true;
            scene.addObject( plane_oxy );
                  
            var cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xFFFFFF, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( "transparent.png" ) } );
            // Y plane back
            cubeMaterial.transparent = true;
            plane_oxy_two = new THREE.Mesh( new THREE.Plane(500, 500, 25, 25 ), cubeMaterial );
            plane_oxy_two.position.x = 0;
            plane_oxy_two.position.y = 250;
            plane_oxy_two.position.z = -250;
            plane_oxy_two.rotation.x = Math.PI;
            plane_oxy_two.overdraw = true;
            scene.addObject( plane_oxy_two );
            
            var cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xFFFFFF, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( "transparent.png" ) } );
            // Z plane front
            plane_ozx = new THREE.Mesh( new THREE.Plane(500, 500, 25, 25 ), cubeMaterial );
            cubeMaterial.transparent = true;
            plane_ozx.position.x = -250;
            plane_ozx.position.y = 250;
            plane_ozx.position.z = 0;
            plane_ozx.rotation.y = ( Math.PI / 2 );
            scene.addObject( plane_ozx );
            
            var cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xFFFFFF, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( "transparent.png" ) } );
            // Z plane back
            cubeMaterial.transparent = true;
            plane_ozx_two = new THREE.Mesh( new THREE.Plane(500, 500, 25, 25 ), cubeMaterial );
            plane_ozx_two.position.x = -250;
            plane_ozx_two.position.y = 250;
            plane_ozx_two.position.z = 0;
            plane_ozx_two.rotation.y = -( Math.PI / 2 );
      
            plane_ozx.overdraw = true;
            scene.addObject( plane_ozx_two );


      place_ozy = new THREE.Mesh( new THREE.Plane( 1000, 1000, 25, 25 ), new THREE.MeshBasicMaterial( { color: 0x555555, wireframe: true } ) );
      place_ozy.position.x = 1000;
      place_ozy.rotation.x = - ( Math.PI / 2 );
      place_ozy.overdraw = true;
      scene.addObject( plane_oxy );
      
      renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setSize(window.innerWidth, window.innerHeight );
      container.appendChild( renderer.domElement );
      
      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;
      
      stats = new Stats();
      stats.domElement.style.position = 'absolute';
      stats.domElement.style.top = '0px';
      container.appendChild( stats.domElement );
      
      animate();
      document.addEventListener( 'mousemove', onDocumentMouseMove, false );
      
      
      function onDocumentMouseMove( event ) {

  				event.preventDefault();

  				mouse2D.x = ( event.clientX / window.innerWidth ) * 2 - 1;
  				mouse2D.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

  			}
        function getRealIntersector( intersects ) {

        				for( i = 0; i < intersects.length; i++ ) {

        					intersector = intersects[ i ];

        					if ( intersector.object == plane_oxz ) {

        						return intersector;

        					}

        				}

        				return null;

        			}
        			
        			function setVoxelPosition( intersector ) {

              				tmpVec.copy( intersector.face.normal );

              				voxelPosition.add( intersector.point, intersector.object.matrixRotationWorld.multiplyVector3( tmpVec ) );

              				voxelPosition.x = Math.floor( voxelPosition.x / 50 ) * 50 + 25;
              				voxelPosition.y = Math.floor( voxelPosition.y / 50 ) * 50 + 25;
              				voxelPosition.z = Math.floor( voxelPosition.z / 50 ) * 50 + 25;

              			}
              			
      function animate(){
        requestAnimationFrame( animate );
        //camera.position.x += (targetRotation - camera.position.x)*0.015;

        //camera.position.y += (sth - camera.position.y)*0.015;
        
        //plane.rotation.z = cube.rotation.y += ( targetRotation - cube.rotation.y ) * 0.015;
        
        //plane.rotation.x = cube.rotation.x += ( sth - cube.rotation.x ) * 0.015;
        mouse3D = projector.unprojectVector( mouse2D.clone(), camera );
        ray.direction = mouse3D.subSelf( camera.position ).normalize();
        var intersects = ray.intersectScene( scene );
        
        if ( intersects.length > 0 ) {
          intersector = getRealIntersector( intersects );
          if ( intersector ) {
            setVoxelPosition( intersector );
            rollOverMesh.position = voxelPosition;
          }
        }
        renderer.render( scene, camera );
        stats.update();
      }
      
		</script> 
 
	</body>
</html>